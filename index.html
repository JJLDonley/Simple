<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Simple | Language, IR, and Bytecode VM</title>
  <meta name="description" content="Simple is a strict language and runtime stack: Simple Lang -> Simple IR -> SBC -> VM." />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="bg-grid" aria-hidden="true"></div>

  <header class="hero wrap">
    <p class="eyebrow">Simple Project</p>
    <div class="hero-row">
      <div class="hero-text">
        <div class="header-logo">
          <div class="header-text">
            <h1>Simple Lang,</h1>
            <h1>Simple IR,</h1> 
            <h1>Simple VM</h1>
          </div>
          <div class="logo-block">
            <div class="logo-wrap">
              <img class="logo" src="SimpleLogo.png" alt="Simple logo" />
            </div>
          </div>
        </div>
        <p class="lead">A strict language and runtime stack focused on predictable behavior, explicit boundaries, and an inspectable pipeline.</p>
        <div class="cta-row">
          <a class="btn solid" href="#quick-start">Get Started</a>
          <a class="btn ghost" href="#core-ideas">Language Core Ideas</a>
          <a class="btn ghost" href="https://github.com/JJLDonley/Simple/releases" target="_blank" rel="noopener noreferrer">Downloads</a>
        </div>
      </div>
    </div>
  </header>

  <main class="wrap">
    <section class="panel" id="why-simple">
      <h2>Why Simple Exists</h2>
      <p>Simple is built around one clear execution story: source code lowers to a readable intermediate form, then to bytecode, then executes in a verified VM. The point is not clever syntax tricks. The point is control: deterministic behavior, clear failure modes, and an architecture you can embed and reason about.</p>
      <div class="pillars">
        <article class="card">
          <h3>Strict by default</h3>
          <p>Types are explicit and validated early. You get fewer hidden conversions and clearer diagnostics.</p>
        </article>
        <article class="card">
          <h3>Pipeline visibility</h3>
          <p>You can inspect SIR and SBC artifacts directly, making compiler/runtime debugging practical.</p>
        </article>
        <article class="card">
          <h3>Embeddable runtime</h3>
          <p>The VM is designed as a host boundary for app scripting, tools, and sandboxed execution.</p>
        </article>
      </div>
    </section>

    <section class="panel" id="supported">
      <h2>Supported Surface</h2>
      <div class="two-col">
        <div>
          <h3>Language</h3>
          <p>Strict typing, explicit mutability, artifacts, enums, modules, and script-style top-level execution.</p>
        </div>
        <div>
          <h3>Pipeline</h3>
          <p>.simple -> SIR -> SBC -> VM execution with loader/verifier gates and deterministic diagnostics.</p>
        </div>
        <div>
          <h3>Runtime</h3>
          <p>Interpreter execution, heap/GC, arrays/lists/strings, and core system module dispatch.</p>
        </div>
        <div>
          <h3>Interop</h3>
          <p>DL-based C/C++ interop with strict extern signatures and ABI marshalling.</p>
        </div>
      </div>
    </section>

    <section class="panel" id="docs">
      <h2>Authoritative Docs</h2>
      <div class="pillars">
        <article class="card">
          <h3>Language</h3>
          <p><a href="https://github.com/JJLDonley/Simple/blob/main/Docs/Lang.md" target="_blank" rel="noopener noreferrer">Docs/Lang.md</a> - syntax, semantics, and validation.</p>
        </article>
        <article class="card">
          <h3>StdLib</h3>
          <p><a href="https://github.com/JJLDonley/Simple/blob/main/Docs/StdLib.md" target="_blank" rel="noopener noreferrer">Docs/StdLib.md</a> - reserved imports and APIs.</p>
        </article>
        <article class="card">
          <h3>IR + Bytecode</h3>
          <p><a href="https://github.com/JJLDonley/Simple/blob/main/Docs/IR.md" target="_blank" rel="noopener noreferrer">Docs/IR.md</a> and <a href="https://github.com/JJLDonley/Simple/blob/main/Docs/Byte.md" target="_blank" rel="noopener noreferrer">Docs/Byte.md</a>.</p>
        </article>
      </div>
    </section>

    <section class="panel" id="core-ideas">
      <h2>Simple Lang: Core Ideas</h2>
      <div class="tabs" data-default="tab-decl">
        <div class="tab-bar" role="tablist" aria-label="Simple core ideas">
          <button class="tab-btn active" role="tab" aria-selected="true" aria-controls="tab-decl" id="btn-decl" data-target="tab-decl">Declarations</button>
          <button class="tab-btn" role="tab" aria-selected="false" aria-controls="tab-mutable" id="btn-mutable" data-target="tab-mutable">Mutability</button>
          <button class="tab-btn" role="tab" aria-selected="false" aria-controls="tab-script" id="btn-script" data-target="tab-script">Scripting</button>
          <button class="tab-btn" role="tab" aria-selected="false" aria-controls="tab-data" id="btn-data" data-target="tab-data">Data Model</button>
          <button class="tab-btn" role="tab" aria-selected="false" aria-controls="tab-system" id="btn-system" data-target="tab-system">System</button>
          <button class="tab-btn" role="tab" aria-selected="false" aria-controls="tab-interop" id="btn-interop" data-target="tab-interop">Interop</button>
        </div>

        <article class="tab-panel active" id="tab-decl" role="tabpanel" aria-labelledby="btn-decl">
          <h3>Declarations are explicit</h3>
          <p>Variables, parameters, and returns are typed. Type mismatches fail at validation.</p>
          <pre><code>count : i32 = 42
label :: string = "ready"

add : i32 (a : i32, b : i32) {
  return a + b
}</code></pre>
          <p class="muted">Strict typing is enforced across variables, parameters, and returns.</p>
        </article>

        <article class="tab-panel" id="tab-mutable" role="tabpanel" aria-labelledby="btn-mutable" hidden>
          <h3>Mutability is explicit</h3>
          <p><code>:</code> is mutable. <code>::</code> is immutable.</p>
          <pre><code>x : i32 = 10
name :: string = "Simple"

x = x + 1        # ok
name = "Next"    # compile error</code></pre>
          <p class="muted">The same rules apply to artifact fields.</p>
        </article>

        <article class="tab-panel" id="tab-script" role="tabpanel" aria-labelledby="btn-script" hidden>
          <h3>Script-style top level</h3>
          <p>Top-level statements execute in source order via implicit <code>__script_entry</code>. Function declarations do not execute implicitly.</p>
          <pre><code>import io
io.println("boot")

sum : i32 (a : i32, b : i32) {
  return a + b
}

io.println(sum(2, 3))</code></pre>
          <p class="muted">An explicit <code>main</code> is used only when no top-level statements exist.</p>
        </article>

        <article class="tab-panel" id="tab-data" role="tabpanel" aria-labelledby="btn-data" hidden>
          <h3>Artifact, Enum, and Module</h3>
          <p>Artifact defines structured layouts with fields and optional methods. Enum is scoped and strongly typed. Module exposes constants.</p>
          <pre><code>Status :: Enum { Idle = 0, Running = 1 }

Player :: Artifact {
  hp : i32
  damage : void (amount : i32) { self.hp -= amount }
}

Config :: Module {
  MAX_PLAYERS :: i32 = 16
}</code></pre>
          <p class="muted">These map cleanly through validation and IR lowering.</p>
        </article>

        <article class="tab-panel" id="tab-system" role="tabpanel" aria-labelledby="btn-system" hidden>
          <h3>System modules are reserved</h3>
          <p>Reserved modules use keyword-style paths. Local modules use quoted paths.</p>
          <pre><code>import io
import dl
import fs

import "raylib"
import "./raylib.simple"</code></pre>
          <p class="muted">Reserved imports map to runtime namespaces defined in <code>Docs/StdLib.md</code>.</p>
        </article>

        <article class="tab-panel" id="tab-interop" role="tabpanel" aria-labelledby="btn-interop" hidden>
          <h3>Interop is first-class</h3>
          <p><code>extern</code> declares native signatures, and <code>DL</code> handles ABI marshaling.</p>
          <pre><code>import dl
import io

extern raylib.InitWindow : void (w: i32, h: i32, title: string)
extern raylib.CloseWindow : void ()

lib: i64 = dl.open("raylib.dll", raylib)
if (lib == 0) {
  io.println("raylib load failed: {}", dl.last_error())
}</code></pre>
          <p class="muted">Signatures are strict; unsupported ABI shapes are rejected.</p>
        </article>
      </div>
    </section>

    <section class="panel" id="pipeline">
      <h2>Compilation + Execution Pipeline</h2>
      <div class="pipeline">
        <div class="stage"><strong>.simple</strong><span>Source program</span></div>
        <div class="arrow">-></div>
        <div class="stage"><strong>.sir</strong><span>Typed/intermediate form</span></div>
        <div class="arrow">-></div>
        <div class="stage"><strong>.sbc</strong><span>Bytecode artifact</span></div>
        <div class="arrow">-></div>
        <div class="stage"><strong>VM</strong><span>Verified execution</span></div>
      </div>
      <pre><code># compile + run source
simple run Tests/simple/hello.simple

# inspect IR
simple emit -ir Tests/simple/math.simple --out math.sir

# build bytecode artifact
simple emit -sbc Tests/simple/math.simple --out math.sbc

# execute bytecode directly
simplevm run math.sbc</code></pre>
    </section>

    <section class="panel" id="layer-explorer">
      <h2>Simple | SIR | SBC Explorer</h2>
      <p>Compare the same intent across source, IR, and bytecode layers.</p>
      <div class="tabs" data-default="tab-simple">
        <div class="tab-bar" role="tablist" aria-label="Simple stack layers">
          <button class="tab-btn active" role="tab" aria-selected="true" aria-controls="tab-simple" id="btn-simple" data-target="tab-simple">Simple</button>
          <button class="tab-btn" role="tab" aria-selected="false" aria-controls="tab-sir" id="btn-sir" data-target="tab-sir">SIR</button>
          <button class="tab-btn" role="tab" aria-selected="false" aria-controls="tab-sbc" id="btn-sbc" data-target="tab-sbc">SBC</button>
        </div>

      <article class="tab-panel active" id="tab-simple" role="tabpanel" aria-labelledby="btn-simple">
        <h3>Simple Lang Source</h3>
        <p>High-level typed source with explicit mutability/import boundaries.</p>
        <pre><code>import io

sum: i32 (a: i32, b: i32) {
  return a + b
}

total: i32 = sum(10, 32)
io.println("total={}", total)</code></pre>
      </article>

      <article class="tab-panel" id="tab-sir" role="tabpanel" aria-labelledby="btn-sir" hidden>
        <h3>SIR Instruction Layer</h3>
        <p>Typed intermediate instructions that are easy to inspect and validate.</p>
        <pre><code>; representative SIR
fn sum(a:i32, b:i32) -> i32 {
  %0 = add.i32 a, b
  ret %0
}

fn __script_entry() -> i32 {
  %1 = const.i32 10
  %2 = const.i32 32
  %3 = call sum(%1, %2)
  call core.io.println_fmt("total={}", %3)
  ret 0
}</code></pre>
        <p class="muted">Common IR codes: <code>const.*</code>, <code>add.i32</code>, <code>call</code>, <code>jmp</code>, <code>ret</code>, <code>load.local</code>, <code>store.local</code>.</p>
      </article>

      <article class="tab-panel" id="tab-sbc" role="tabpanel" aria-labelledby="btn-sbc" hidden>
        <h3>SBC + VM Opcode Layer</h3>
        <p>Verified bytecode instructions executed by the VM interpreter/JIT path.</p>
        <pre><code>; representative SBC opcodes
CONST_I32   10
CONST_I32   32
CALL        sum
STORE_LOCAL 0
LOAD_LOCAL  0
IMPORT_CALL core.io.println_fmt
RET_I32     0</code></pre>
        <p class="muted">Frequently used VM opcodes: <code>CONST_I32</code>, <code>ADD_I32</code>, <code>SUB_I32</code>, <code>MUL_I32</code>, <code>DIV_I32</code>, <code>CALL</code>, <code>CALL_INDIRECT</code>, <code>JMP</code>, <code>JMP_TRUE</code>, <code>JMP_FALSE</code>, <code>RET</code>.</p>
      </article>
      </div>
    </section>

    <section class="panel" id="vm-architecture">
      <h2>VM Architecture</h2>
      <p>The VM is split into explicit subsystems so behavior remains auditable and testable.</p>
      <div class="vm-grid">
        <article class="vm-item">
          <h3>Loader</h3>
          <p>Parses SBC sections, metadata, constants, and signatures into a runtime module representation.</p>
        </article>
        <article class="vm-item">
          <h3>Verifier</h3>
          <p>Rejects malformed bytecode and invalid type/control-flow combinations before any execution starts.</p>
        </article>
        <article class="vm-item">
          <h3>Interpreter</h3>
          <p>Executes opcodes with strict checks and deterministic semantics. Traps are explicit and testable.</p>
        </article>
        <article class="vm-item">
          <h3>System Boundary</h3>
          <p>System modules expose controlled host services for IO, files, math, OS, and dynamic loading.</p>
        </article>
        <article class="vm-item">
          <h3>Embedding Interface</h3>
          <p>Host apps can compile/load/run modules and control runtime lifecycle for plugin or script scenarios.</p>
        </article>
        <article class="vm-item">
          <h3>JIT Path (in progress)</h3>
          <p>Tiering exists; optimization is ongoing. Baseline correctness and coverage still take priority.</p>
        </article>
      </div>
    </section>

    <section class="panel" id="stdlib">
      <h2>System Libraries and Responsibility Split</h2>
      <p>Simple keeps system features modular to avoid overlap and make dependency intent explicit.</p>
      <div class="tabs" data-default="tab-lib-io">
        <div class="tab-bar" role="tablist" aria-label="System libraries">
          <button class="tab-btn active" role="tab" aria-selected="true" aria-controls="tab-lib-io" id="btn-lib-io" data-target="tab-lib-io">System.io</button>
          <button class="tab-btn" role="tab" aria-selected="false" aria-controls="tab-lib-file" id="btn-lib-file" data-target="tab-lib-file">System.file</button>
          <button class="tab-btn" role="tab" aria-selected="false" aria-controls="tab-lib-math" id="btn-lib-math" data-target="tab-lib-math">System.math / time</button>
          <button class="tab-btn" role="tab" aria-selected="false" aria-controls="tab-lib-osdl" id="btn-lib-osdl" data-target="tab-lib-osdl">System.os / dl</button>
        </div>

        <article class="tab-panel active" id="tab-lib-io" role="tabpanel" aria-labelledby="btn-lib-io">
          <table class="api-table">
            <thead>
              <tr><th>Function</th><th>Purpose</th></tr>
            </thead>
            <tbody>
              <tr><td><code>buffer_new(length)</code></td><td>Create a new i32 buffer/list of requested length.</td></tr>
              <tr><td><code>buffer_len(buffer)</code></td><td>Return current buffer length.</td></tr>
              <tr><td><code>buffer_fill(buffer, value, count)</code></td><td>Fill up to <code>count</code> slots with <code>value</code>; returns written count.</td></tr>
              <tr><td><code>buffer_copy(dst, src, count)</code></td><td>Copy up to <code>count</code> elements from source to destination.</td></tr>
              <tr><td><code>print(value)</code> / <code>println(value)</code></td><td>Stream output for scalar/format-based text emission.</td></tr>
            </tbody>
          </table>
        </article>

        <article class="tab-panel" id="tab-lib-file" role="tabpanel" aria-labelledby="btn-lib-file" hidden>
          <table class="api-table">
            <thead>
              <tr><th>Function</th><th>Purpose</th></tr>
            </thead>
            <tbody>
              <tr><td><code>open(path, mode)</code></td><td>Open file and return handle/id for follow-up operations.</td></tr>
              <tr><td><code>read(handle, buffer, count)</code></td><td>Read bytes/values into provided buffer; returns read count.</td></tr>
              <tr><td><code>write(handle, buffer, count)</code></td><td>Write bytes/values from buffer; returns written count.</td></tr>
              <tr><td><code>close(handle)</code></td><td>Close file handle and release underlying resource.</td></tr>
            </tbody>
          </table>
        </article>

        <article class="tab-panel" id="tab-lib-math" role="tabpanel" aria-labelledby="btn-lib-math" hidden>
          <table class="api-table">
            <thead>
              <tr><th>Function</th><th>Purpose</th></tr>
            </thead>
            <tbody>
              <tr><td><code>sqrt(x)</code></td><td>Square root for numeric values.</td></tr>
              <tr><td><code>abs(x)</code></td><td>Absolute value helper.</td></tr>
              <tr><td><code>pow(x, y)</code></td><td>Power/exponent helper.</td></tr>
              <tr><td><code>now()</code></td><td>Retrieve current time/tick value for timing logic.</td></tr>
            </tbody>
          </table>
        </article>

        <article class="tab-panel" id="tab-lib-osdl" role="tabpanel" aria-labelledby="btn-lib-osdl" hidden>
          <table class="api-table">
            <thead>
              <tr><th>Function / Value</th><th>Purpose</th></tr>
            </thead>
            <tbody>
              <tr><td><code>supported</code> / <code>has_dl</code></td><td>Capability flags for dynamic loading support.</td></tr>
              <tr><td><code>is_linux</code> / <code>is_macos</code> / <code>is_windows</code></td><td>Platform feature flags for branching behavior safely.</td></tr>
              <tr><td><code>open(path)</code></td><td>Open dynamic library and return handle.</td></tr>
              <tr><td><code>sym(handle, name)</code></td><td>Resolve symbol pointer from a dynamic library.</td></tr>
              <tr><td><code>close(handle)</code></td><td>Close dynamic library handle.</td></tr>
              <tr><td><code>last_error()</code></td><td>Return diagnostic message from latest DL operation.</td></tr>
            </tbody>
          </table>
        </article>
      </div>
    </section>

    <section class="panel" id="cli">
      <h2>CLI Quick Reference</h2>
      <div class="two-col">
        <div>
          <h3>Commands</h3>
          <p><code>run</code>, <code>check</code>, <code>build</code>, <code>compile</code>, <code>emit</code>, <code>lsp</code></p>
        </div>
        <div>
          <h3>Inputs</h3>
          <p><code>.simple</code>, <code>.sir</code>, <code>.sbc</code> (VM path)</p>
        </div>
        <div>
          <h3>Version</h3>
          <p><code>simple --version</code>, <code>simple -v</code>, <code>simple version</code></p>
        </div>
        <div>
          <h3>Build Scripts</h3>
          <p><code>./build_linux</code>, <code>./build_macos</code>, <code>./build_windows</code></p>
        </div>
      </div>
    </section>

    <section class="panel" id="interop">
      <h2>Interop With C/C++</h2>
      <p>Use <code>extern</code> to declare native symbols and call them through <code>DL</code>.</p>
      <pre><code>import dl
import io

extern raylib.InitWindow : void (w: i32, h: i32, title: string)
extern raylib.CloseWindow : void ()

lib: i64 = dl.open("raylib.dll", raylib)
if (lib == 0) {
  io.println("raylib load failed: {}", dl.last_error())
}

raylib.InitWindow(800, 450, "Simple + raylib")
raylib.CloseWindow()</code></pre>
    </section>

    <section class="panel" id="examples">
      <h2>Practical Examples</h2>
      <div class="examples-grid">
        <article class="example">
          <h3>Script-style execution</h3>
          <p>Top-level statements execute in order.</p>
          <pre><code>import io
io.println("hello")
io.println(10 + 20)</code></pre>
        </article>
        <article class="example">
          <h3>Structured data + behavior</h3>
          <p>Artifacts give explicit member layout and typed access.</p>
          <pre><code>Point :: Artifact { x: i32 y: i32 }

sum: i32 (p: Point) {
  return p.x + p.y
}</code></pre>
        </article>
        <article class="example">
          <h3>Inspect then run</h3>
          <p>Use the same program through each stage of the stack.</p>
          <pre><code>simple emit -ir app.simple --out app.sir
simple emit -sbc app.simple --out app.sbc
simplevm run app.sbc</code></pre>
        </article>
      </div>
    </section>

    <section class="panel" id="quick-start">
      <h2>Quick Start</h2>
      <pre><code>git clone https://github.com/JJLDonley/Simple
cd Simple
./build.sh --suite all
./bin/simple run Tests/simple/hello.simple</code></pre>
      <p class="muted">Releases: <a href="https://github.com/JJLDonley/Simple/releases" target="_blank" rel="noopener noreferrer">github.com/JJLDonley/Simple/releases</a></p>
    </section>
  </main>

  <footer class="wrap footer">
    <p>Simple Project • Language + IR + VM • <a href="https://github.com/JJLDonley/Simple" target="_blank" rel="noopener noreferrer">Source</a></p>
  </footer>
  <script>
    (function() {
      document.querySelectorAll(".tabs").forEach(function(group) {
        var buttons = group.querySelectorAll(".tab-btn");
        var panels = group.querySelectorAll(".tab-panel");
        function selectTab(targetId) {
          buttons.forEach(function(btn) {
            var on = btn.getAttribute("data-target") === targetId;
            btn.classList.toggle("active", on);
            btn.setAttribute("aria-selected", on ? "true" : "false");
          });
          panels.forEach(function(panel) {
            var on = panel.id === targetId;
            panel.classList.toggle("active", on);
            panel.hidden = !on;
          });
        }
        buttons.forEach(function(btn) {
          btn.addEventListener("click", function() {
            selectTab(btn.getAttribute("data-target"));
          });
        });
        selectTab(group.getAttribute("data-default"));
      });

      function escHtml(s) {
        return s
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }

      function highlightSimpleCode(raw) {
        var text = escHtml(raw);
        var placeholders = [];
        function take(re, cls) {
          text = text.replace(re, function(m) {
            var id = placeholders.length;
            placeholders.push('<span class="' + cls + '">' + m + "</span>");
            return "__TOK_" + id + "__";
          });
        }

        take(/"(?:[^"\\]|\\.)*"/g, "tok-str");
        take(/(?:^|\s)(#.*)$/gm, "tok-cmt");
        take(/(?:^|\s)(;.*)$/gm, "tok-cmt");
        take(/\b(?:\d+\.\d+|\d+)\b/g, "tok-num");
        take(/\b(?:artifact|enum|module|Artifact|Enum|Module)\b/g, "tok-kw-strong");
        take(/\b(?:import|extern|if|else|return|fn|call|void)\b/g, "tok-kw");
        take(/\b(?:i8|i16|i32|i64|u8|u16|u32|u64|f32|f64|bool|string|char)\b/g, "tok-type");
        take(/\b(?:CONST_I32|ADD_I32|SUB_I32|MUL_I32|DIV_I32|CALL|CALL_INDIRECT|JMP|JMP_TRUE|JMP_FALSE|RET|RET_I32|STORE_LOCAL|LOAD_LOCAL|IMPORT_CALL)\b/g, "tok-op");
        take(/\b(?:dl|io|raylib|core\.io|ffi)\b/g, "tok-fn");

        return text.replace(/__TOK_(\d+)__/g, function(_, i) {
          return placeholders[Number(i)];
        });
      }

      document.querySelectorAll("pre code").forEach(function(block) {
        block.innerHTML = highlightSimpleCode(block.textContent || "");
      });
    })();
  </script>
</body>
</html>
