; Average 10 colors stored as separate RGBA arrays (i32).
func main locals=12 stack=16
  enter 12
  const.i32 10
  stloc 0         ; n

  newarray 0 10
  stloc 1         ; r[]
  newarray 0 10
  stloc 2         ; g[]
  newarray 0 10
  stloc 3         ; b[]
  newarray 0 10
  stloc 4         ; a[]

  const.i32 0
  stloc 5         ; i

fill:
  ldloc 5
  ldloc 0
  cmp.lt.i32
  jmp.false sum

  ; r[i] = i * 10
  ldloc 1
  ldloc 5
  ldloc 5
  const.i32 10
  mul.i32
  array.set.i32

  ; g[i] = i * 20
  ldloc 2
  ldloc 5
  ldloc 5
  const.i32 20
  mul.i32
  array.set.i32

  ; b[i] = 100 - i
  ldloc 3
  ldloc 5
  const.i32 100
  ldloc 5
  sub.i32
  array.set.i32

  ; a[i] = 255
  ldloc 4
  ldloc 5
  const.i32 255
  array.set.i32

  ldloc 5
  const.i32 1
  add.i32
  stloc 5
  jmp fill

sum:
  const.i32 0
  stloc 6         ; sumR
  const.i32 0
  stloc 7         ; sumG
  const.i32 0
  stloc 8         ; sumB
  const.i32 0
  stloc 9         ; sumA

  const.i32 0
  stloc 5         ; i

acc:
  ldloc 5
  ldloc 0
  cmp.lt.i32
  jmp.false avg

  ldloc 6
  ldloc 1
  ldloc 5
  array.get.i32
  add.i32
  stloc 6

  ldloc 7
  ldloc 2
  ldloc 5
  array.get.i32
  add.i32
  stloc 7

  ldloc 8
  ldloc 3
  ldloc 5
  array.get.i32
  add.i32
  stloc 8

  ldloc 9
  ldloc 4
  ldloc 5
  array.get.i32
  add.i32
  stloc 9

  ldloc 5
  const.i32 1
  add.i32
  stloc 5
  jmp acc

avg:
  ldloc 6
  const.i32 10
  div.i32
  stloc 10        ; avgR

  ldloc 7
  const.i32 10
  div.i32
  stloc 11        ; avgG

  ldloc 8
  const.i32 10
  div.i32
  stloc 6         ; reuse sumR slot for avgB

  ldloc 9
  const.i32 10
  div.i32
  stloc 7         ; reuse sumG slot for avgA

  ; pack = (avgR<<24) | (avgG<<16) | (avgB<<8) | avgA
  ldloc 10
  const.i32 24
  shl.i32
  ldloc 11
  const.i32 16
  shl.i32
  or.i32
  ldloc 6
  const.i32 8
  shl.i32
  or.i32
  ldloc 7
  or.i32

  ret
end
entry main
